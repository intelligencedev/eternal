/Users/arturoaquino/Documents/eternal/
├── config.go
├── config_team.go
├── db.go
├── errors.go
├── globals.go
├── handlers_chat.go
├── handlers_models.go
├── handlers_tools.go
├── host.go
├── main.go
├── projects.go
├── routes.go
--- BEGIN /Users/arturoaquino/Documents/eternal/handlers_models.go ---
package main

import (
	"errors"
	"eternal/pkg/hfutils"
	"eternal/pkg/llm"
	"eternal/pkg/llm/openai"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/log"
	"github.com/pterm/pterm"
	"gorm.io/gorm"
)

// handleModelData retrieves and returns data for a specific model.
func handleModelData() fiber.Handler {
	return func(c *fiber.Ctx) error {
		var model ModelParams
		modelName := c.Params("modelName")
		err := sqliteDB.First(modelName, &model)

		if err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				return c.Status(fiber.StatusNotFound).SendString("Model not found")
			}
			return c.Status(fiber.StatusInternalServerError).SendString("Server Error")
		}

		return c.JSON(model)
	}
}

// handleModelDownloadUpdate updates the download status of a model.
func handleModelDownloadUpdate() fiber.Handler {
	return func(c *fiber.Ctx) error {
		modelName := c.Params("modelName")
		var payload struct {
			Downloaded bool `json:"downloaded"`
		}

		if err := c.BodyParser(&payload); err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Cannot parse JSON"})
		}

		err := sqliteDB.UpdateDownloadedByName(modelName, payload.Downloaded)
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": fmt.Sprintf("Failed to update model: %v", err)})
		}

		return c.JSON(fiber.Map{
			"success": true,
			"message": "Model 'Downloaded' status updated successfully",
		})
	}
}

// handleModelUpdate updates the model data in the database.
func handleModelUpdate() fiber.Handler {
	return func(c *fiber.Ctx) error {
		var model ModelParams
		if err := c.BodyParser(&model); err != nil {
			return c.Status(fiber.StatusBadRequest).SendString("Cannot parse JSON")
		}

		err := sqliteDB.UpdateByName(model.Name, model)
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).SendString("Server Error")
		}

		return c.JSON(model)
	}
}

// handleModelCards retrieves and renders model cards.
func handleModelCards(modelParams []ModelParams) fiber.Handler {
	return func(c *fiber.Ctx) error {
		err := sqliteDB.Find(&modelParams)

		if err != nil {
			log.Errorf("Database error: %v", err)
			return c.Status(500).SendString("Server Error")
		}

		return c.Render("templates/model", fiber.Map{"models": modelParams})
	}
}

// handleModelSelect handles the selection of models for use.
func handleModelSelect() fiber.Handler {
	return func(c *fiber.Ctx) error {
		modelName := c.Params("name")
		action := c.Params("action")

		if action == "add" {
			if err := AddSelectedModel(sqliteDB.db, modelName); err != nil {
				return c.Status(fiber.StatusInternalServerError).SendString("Server Error")
			}
		} else if action == "remove" {
			if err := RemoveSelectedModel(sqliteDB.db, modelName); err != nil {
				return c.Status(fiber.StatusInternalServerError).SendString("Server Error")
			}
		} else {
			return c.Status(fiber.StatusBadRequest).SendString("Invalid action")
		}

		return c.SendStatus(fiber.StatusOK)
	}
}

// handleSelectedModels retrieves and returns the list of selected models.
func handleSelectedModels() fiber.Handler {
	return func(c *fiber.Ctx) error {
		selectedModels, err := GetSelectedModels(sqliteDB.db)

		if err != nil {
			log.Errorf("Error getting selected models: %v", err)
			return c.Status(500).SendString("Server Error")
		}

		var selectedModelNames []string
		for _, model := range selectedModels {
			selectedModelNames = append(selectedModelNames, model.ModelName)
		}

		return c.JSON(selectedModelNames)
	}
}

// handleModelDownload handles the download of a specified model.
func handleModelDownload(config *AppConfig) fiber.Handler {
	return func(c *fiber.Ctx) error {
		pterm.Error.Println("Download route hit")
		modelName := c.Query("model")

		if modelName == "" {
			log.Errorf("Missing parameters for download")
			return c.Status(fiber.StatusBadRequest).SendString("Missing parameters")
		}

		var downloadURL string
		for _, model := range config.LanguageModels {
			if model.Name == modelName {
				downloadURL = model.Downloads[0]
				break
			}
		}

		modelFileName := filepath.Base(downloadURL)
		modelPath := filepath.Join(config.DataPath, "models", modelName, modelFileName)

		var partialDownload bool
		if info, err := os.Stat(modelPath); err == nil {
			if info.Size() > 0 {
				expectedSize, err := llm.GetExpectedFileSize(downloadURL)
				if err != nil {
					log.Errorf("Error getting expected file size: %v", err)
				}
				partialDownload = info.Size() < expectedSize
			}
		}

		go func() {
			var err error

			if partialDownload {
				pterm.Info.Printf("Resuming download for model: %s\n", modelName)
				err = llm.Download(downloadURL, modelPath)
			} else {
				pterm.Info.Printf("Starting download for model: %s\n", modelName)
				err = llm.Download(downloadURL, modelPath)
			}

			if err != nil {
				log.Errorf("Error in download: %v", err)
			} else {
				err = sqliteDB.UpdateDownloadedByName(modelName, true)
				if err != nil {
					log.Errorf("Failed to update model downloaded state: %v", err)
				}
			}
		}()

		progressErr := fmt.Sprintf("<div class='w-100' id='progress-download-%s' hx-ext='sse' sse-connect='/sseupdates' sse-swap='message' hx-trigger='load'></div>", modelName)

		return c.SendString(progressErr)
	}
}

// handleImgModelDownload handles the download of image generation models.
func handleImgModelDownload(config *AppConfig) fiber.Handler {
	return func(c *fiber.Ctx) error {
		config.Tools.ImgGen.Enabled = true

		modelName := c.Query("model")

		var downloadURL string
		for _, model := range config.ImageModels {
			if model.Name == modelName {
				downloadURL = model.Downloads[0]
			}
		}

		modelFileName := strings.Split(downloadURL, "/")[len(strings.Split(downloadURL, "/"))-1]

		if modelName == "" {
			log.Errorf("Missing parameters for download")
			return c.Status(fiber.StatusBadRequest).SendString("Missing parameters")
		}

		modelRoot := fmt.Sprintf("%s/models/%s", config.DataPath, modelName)
		modelPath := fmt.Sprintf("%s/models/%s/%s", config.DataPath, modelName, modelFileName)
		tmpPath := fmt.Sprintf("%s/tmp", config.DataPath)

		if _, err := os.Stat(modelRoot); os.IsNotExist(err) {
			if err := os.MkdirAll(modelRoot, 0755); err != nil {
				log.Errorf("Error creating model directory: %v", err)
				return c.Status(fiber.StatusInternalServerError).SendString("Server Error")
			}
		}

		if _, err := os.Stat(tmpPath); os.IsNotExist(err) {
			if err := os.MkdirAll(tmpPath, 0755); err != nil {
				log.Errorf("Error creating tmp directory: %v", err)
				return c.Status(fiber.StatusInternalServerError).SendString("Server Error")
			}
		}

		if _, err := os.Stat(modelPath); err != nil {
			dm := hfutils.ConcurrentDownloadManager{
				FileName:    modelFileName,
				URL:         downloadURL,
				Destination: modelPath,
				NumParts:    1,
				TempDir:     tmpPath,
			}

			go dm.PrintProgress()

			if err := dm.Download(); err != nil {
				fmt.Println("Download failed:", err)
			} else {
				fmt.Println("Download successful!")
			}
		}

		vaeName := "sdxl_vae.safetensors"
		vaeURL := "https://huggingface.co/madebyollin/sdxl-vae-fp16-fix/blob/main/sdxl_vae.safetensors"
		vaePath := fmt.Sprintf("%s/models/%s/%s", config.DataPath, modelName, vaeName)

		if _, err := os.Stat(modelRoot); os.IsNotExist(err) {
			if err := os.MkdirAll(modelRoot, 0755); err != nil {
				log.Errorf("Error creating model directory: %v", err)
				return c.Status(fiber.StatusInternalServerError).SendString("Server Error")
			}
		}

		if _, err := os.Stat(vaePath); os.IsNotExist(err) {
			go func() {
				response, err := http.Get(vaeURL)
				if err != nil {
					pterm.Error.Printf("Failed to download file: %v", err)
					return
				}
				defer response.Body.Close()

				file, err := os.Create(vaePath)
				if err != nil {
					pterm.Error.Printf("Failed to create file: %v", err)
					return
				}
				defer file.Close()

				_, err = io.Copy(file, response.Body)
				if err != nil {
					pterm.Error.Printf("Failed to write to file: %v", err)
					return
				}

				pterm.Info.Printf("Downloaded file: %s", vaeName)
			}()
		}

		progressErr := "<div name='sse-messages' class='w-100' id='sse-messages' hx-ext='sse' sse-connect='/sseupdates' sse-swap='message'></div>"

		return c.SendString(progressErr)
	}
}

// handleOpenAIModels retrieves and returns a list of OpenAI models.
func handleOpenAIModels(config *AppConfig) fiber.Handler {
	return func(c *fiber.Ctx) error {
		client := openai.NewClient(config.OAIKey)
		modelsResponse, err := openai.GetModels(client)

		if err != nil {
			log.Errorf(err.Error())
			return c.Status(500).SendString("Server Error")
		}

		var gptModels []string
		for _, model := range modelsResponse.Data {
			if strings.HasPrefix(model.ID, "gpt") {
				gptModels = append(gptModels, model.ID)
			}
		}

		return c.JSON(fiber.Map{
			"object": "list",
			"data":   gptModels,
		})
	}
}
--- END /Users/arturoaquino/Documents/eternal/handlers_models.go ---

--- BEGIN /Users/arturoaquino/Documents/eternal/handlers_tools.go ---
package main

import (
	"context"
	"errors"
	"eternal/pkg/sd"
	"eternal/pkg/web"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/log"
	"github.com/gofiber/websocket/v2"
	"github.com/pterm/pterm"
)

// performToolWorkflow performs the tool workflow on a chat message.
func performToolWorkflow(c *websocket.Conn, config *AppConfig, chatMessage string) string {

	// Begin tool workflow. Tools will add context to the submitted message for the model to use.
	var document string

	if config.Tools.ImgGen.Enabled {
		pterm.Info.Println("Generating image...")
		sdParams := &sd.SDParams{Prompt: chatMessage}

		// Call the sd tool.
		res := sd.Text2Image(config.DataPath, sdParams)
		if res != nil {
			pterm.Error.Println("Error generating image:", res)
			return chatMessage
		}

		// Return the image to the client.
		timestamp := time.Now().UnixNano() // Get the current timestamp in nanoseconds.
		imgElement := fmt.Sprintf("<img class='rounded-2 object-fit-scale' width='512' height='512' src='public/tmp/sd_out.png?%d' />", timestamp)
		formattedContent := fmt.Sprintf("<div id='response-content-%s' class='mx-1' hx-trigger='load'>%s</div>", fmt.Sprint(chatTurn), imgElement)
		if err := c.WriteMessage(websocket.TextMessage, []byte(formattedContent)); err != nil {
			pterm.PrintOnError(err)
			return chatMessage
		}

		// Increment the chat turn counter.
		chatTurn = chatTurn + 1

		// End the tool workflow.
		return chatMessage
	}

	if config.Tools.Memory.Enabled {
		document, _ = handleChatMemory(config, chatMessage)
	}

	if config.Tools.WebGet.Enabled {
		url := web.ExtractURLs(chatMessage)
		if len(url) > 0 {
			pterm.Info.Println("Retrieving page content...")

			document, _ = web.WebGetHandler(url[0])

			// Add the page content to the chat message.

		}
	}

	if config.Tools.WebSearch.Enabled {
		topN := config.Tools.WebSearch.TopN

		pterm.Info.Println("Searching the web...")

		var urls []string
		switch config.Tools.WebSearch.Name {
		case "ddg":
			urls = web.SearchDDG(chatMessage)
		case "sxng":
			urls = web.GetSearXNGResults(config.Tools.WebSearch.Endpoint, chatMessage)
		}

		//pterm.Warning.Printf("URLs to fetch: %v\n", urls)

		ignoredURLs, err := sqliteDB.ListURLTrackings()
		if err != nil {
			log.Errorf("Error listing URL trackings: %v", err)
		}

		// match the ignored URLs with the fetched URLs and remove them from the list
		for _, ignoredURL := range ignoredURLs {
			for i, url := range urls {
				if strings.Contains(url, ignoredURL.URL) {
					urls = append(urls[:i], urls[i+1:]...)

					pterm.Warning.Printf("Ignoring URL: %s\n", ignoredURL.URL)
				}
			}
		}

		var wg sync.WaitGroup
		urlsChan := make(chan string, len(urls))
		failedURLsChan := make(chan []string)
		pagesChan := make(chan string, topN)
		done := make(chan struct{})

		// Fetch URLs concurrently
		for _, url := range urls {
			wg.Add(1)
			go func(u string) {
				defer wg.Done()
				select {
				case <-done:
					return
				default:
					pterm.Info.Printf("Fetching URL: %s\n", u)
					page, err := web.WebGetHandler(u)
					if err != nil {
						if errors.Is(err, context.DeadlineExceeded) {
							pterm.Warning.Printf("Timeout exceeded for URL: %s\n", u)

							// Add the URL to the channel to be processed later
							failedURLsChan <- []string{u}
						} else {
							log.Errorf("Error fetching URL: %v", err)

							failedURLsChan <- []string{u}
						}
						return
					}

					// Prepent the URL to the page content
					page = fmt.Sprintf("%s\n%s", u, page)

					urlsChan <- page
				}
			}(url)
		}

		// Close urlsChan when all fetches are done
		go func() {
			wg.Wait()
			close(urlsChan)
			close(failedURLsChan)
		}()

		// Collect topN pages
		go func() {
			var pagesRetrieved int
			for page := range urlsChan {
				if pagesRetrieved >= topN {
					close(done)
					break
				}
				pagesChan <- page
				pagesRetrieved++
			}
			close(pagesChan)
		}()

		// Process failed URLs
		var failedURLs []string
		for url := range failedURLsChan {
			failedURLs = append(failedURLs, url...)

			// Insert the failed URLs back into the URLTracking table
			for _, failedURL := range failedURLs {
				// Parse the top-level domain from the URL by splitting the URL by slashes and getting the second element.
				tld := strings.Split(failedURL, "/")[2]

				err := sqliteDB.CreateURLTracking(tld)
				if err != nil {
					log.Errorf("Error inserting failed URL into database: %v", err)
				}
			}
		}

		// Retreve the failed URLs from the URLTracking table
		trackedURLs, err := sqliteDB.ListURLTrackings()
		if err != nil {
			log.Errorf("Error listing URL trackings: %v", err)
		}

		// Print the failed URLs
		for _, trackedURL := range trackedURLs {
			pterm.Warning.Printf("New failed URL: %s\n", trackedURL.URL)
		}

		// Process pages
		var document string
		for page := range pagesChan {
			// Parse the first line of the page to get the URL
			pageURL := strings.Split(page, "\n")[0]
			documentTags := fmt.Sprintf("web, %s", pageURL)
			err := handleTextSplitAndIndex(documentTags, page, 1024, "avsolatorio/GIST-small-Embedding-v0")
			if err != nil {
				log.Errorf("Error handling text split and index: %v", err)
			}
			document = fmt.Sprintf("%s\n%s", document, page)
		}

		pterm.Error.Printf("Fetching web search chunks from memory...")
		document, _ = handleChatMemory(config, chatMessage)
		//pterm.Error.Printf("Web Search Document: %s\n", document)
		chatMessage = fmt.Sprintf("%s Reference the previous information if it is relevant to the next query only. Do not provide any additional information other than what is necessary to answer the next question or respond to the query. Be concise. Do not deviate from the topic of the query.\nQUERY:\n%s", document, chatMessage)

		pterm.Info.Println("Tool workflow complete")

		return chatMessage
	}

	chatMessage = fmt.Sprintf("REFERENCE DOCUMENT:\n%s\n\nQUERY:\n%s", document, chatMessage)

	pterm.Info.Println("Tool workflow complete")

	return chatMessage
}

// handleToolToggle toggles the state of various tools based on the provided tool name.
func handleToolToggle(config *AppConfig) fiber.Handler {
	return func(c *fiber.Ctx) error {
		toolName := c.Params("toolName")
		enabled := c.Params("enabled")
		topN := c.Params("topN")

		pterm.Info.Println(enabled)

		// Convert the enabled parameter to a boolean.
		enabledBool, err := strconv.ParseBool(enabled)
		if err != nil {
			return c.Status(fiber.StatusBadRequest).SendString("Invalid enabled parameter")
		}

		// Convert the topN parameter to an integer.
		topNInt, err := strconv.Atoi(topN)
		if err != nil {
			return c.Status(fiber.StatusBadRequest).SendString("Invalid topN parameter")
		}

		// Print the params to the console.
		pterm.Info.Println("Params:")
		pterm.Info.Println(toolName)

		switch toolName {
		case "memory":
			pterm.Warning.Sprintf("Memory tool toggled: %t\n", config.Tools.Memory.Enabled)
			config.Tools.Memory.Enabled = enabledBool
			config.Tools.Memory.TopN = topNInt
		case "webget":
			pterm.Warning.Sprintf("WebGet tool toggled: %t\n", config.Tools.WebGet.Enabled)
			config.Tools.WebGet.Enabled = !config.Tools.WebGet.Enabled
		case "websearch":
			pterm.Warning.Sprintf("WebSearch tool toggled: %t\n", config.Tools.WebSearch.Enabled)
			config.Tools.WebSearch.Enabled = enabledBool
			config.Tools.WebSearch.TopN = topNInt
		case "imggen":
			config.Tools.ImgGen.Enabled = true
		default:
			return c.Status(fiber.StatusNotFound).SendString("Tool not found")
		}

		return c.JSON(fiber.Map{
			"message": fmt.Sprintf("Tool %s toggled", toolName)})
	}
}

// handleToolList retrieves and returns a list of tools from the configuration with all parameters.
func handleToolList(config *AppConfig) fiber.Handler {
	return func(c *fiber.Ctx) error {
		return c.JSON(config.Tools)
	}
}

// handleRoleSelection handles the selection of assistant roles.
func handleRoleSelection(config *AppConfig) fiber.Handler {
	return func(c *fiber.Ctx) error {
		roleName := c.Params("name")
		var foundRole *struct {
			Name         string `yaml:"name"`
			Instructions string `yaml:"instructions"`
		}

		for i := range config.AssistantRoles {
			if config.AssistantRoles[i].Name == roleName {
				foundRole = &config.AssistantRoles[i]
				break
			}
		}

		if foundRole == nil {
			pterm.Warning.Printf("Role %s not found. Defaulting to 'chat'.\n", roleName)
			for i := range config.AssistantRoles {
				if config.AssistantRoles[i].Name == "chat" {
					foundRole = &config.AssistantRoles[i]
					break
				}
			}
		}

		if foundRole == nil && len(config.AssistantRoles) > 0 {
			foundRole = &config.AssistantRoles[0]
			return c.JSON(fiber.Map{
				"message": fmt.Sprintf("Role set to %s", foundRole.Name),
			})
		}

		if foundRole != nil {
			config.CurrentRoleInstructions = foundRole.Instructions
			pterm.Info.Printf("Role set to: %s\n", foundRole.Name)
			pterm.Info.Println(foundRole.Instructions)
			return c.JSON(fiber.Map{
				"message": fmt.Sprintf("Role set to %s", foundRole.Name),
			})
		}

		return c.Status(fiber.StatusInternalServerError).SendString("Server Error")
	}
}
--- END /Users/arturoaquino/Documents/eternal/handlers_tools.go ---

--- BEGIN /Users/arturoaquino/Documents/eternal/host.go ---
// NOTE: Thiese functions are not implemented in the main app yet.
package main

import (
	// Importing necessary packages for executing commands, formatting strings, and hardware information retrieval.
	"bytes"
	"fmt"
	"os/exec"
	"runtime"
	"strings"

	"github.com/jaypipes/ghw"        // Package for hardware information
	"github.com/shirou/gopsutil/mem" // Package for system memory information
)

// HostInfo struct: Stores information about the host system.
type HostInfo struct {
	OS     string `json:"os"`   // Operating System
	Arch   string `json:"arch"` // Architecture (e.g., amd64, 386)
	CPUs   int    `json:"cpus"` // Number of CPUs
	Memory struct {
		Total uint64 `json:"total"` // Total memory in bytes
	} `json:"memory"`
	GPUs []GPUInfo `json:"gpus"` // Slice of GPU information
}

// GPUInfo struct: Stores information about GPUs in the system.
type GPUInfo struct {
	Model              string `json:"model"`                 // GPU model
	TotalNumberOfCores string `json:"total_number_of_cores"` // Total cores in GPU
	MetalSupport       string `json:"metal_support"`         // Metal support (specific to macOS)
}

// GetHostInfo function: Retrieves information about the host system.
func GetHostInfo() (HostInfo, error) {
	hostInfo := HostInfo{
		OS:   runtime.GOOS,     // Fetching OS
		Arch: runtime.GOARCH,   // Fetching architecture
		CPUs: runtime.NumCPU(), // Fetching CPU count
	}

	// Retrieve memory information using gopsutil
	vmStat, _ := mem.VirtualMemory()
	hostInfo.Memory.Total = vmStat.Total

	// GPU information retrieval based on OS
	switch runtime.GOOS {
	case "darwin":
		// macOS specific GPU information retrieval
		gpus, err := getMacOSGPUInfo()
		if err != nil {
			fmt.Printf("Error getting GPU info: %v\n", err)
		} else {
			hostInfo.GPUs = append(hostInfo.GPUs, gpus)
		}

	case "linux", "windows":
		// Linux and Windows GPU information retrieval
		gpu, err := ghw.GPU()
		if err != nil {
			fmt.Printf("Error getting GPU info: %v\n", err)
		} else {
			for _, card := range gpu.GraphicsCards {
				gpuInfo := GPUInfo{
					Model: card.DeviceInfo.Product.Name, // Fetching GPU model
				}
				hostInfo.GPUs = append(hostInfo.GPUs, gpuInfo)
			}
		}
	}

	return hostInfo, nil
}

// getMacOSGPUInfo function: Retrieves GPU information for macOS.
func getMacOSGPUInfo() (GPUInfo, error) {
	cmd := exec.Command("system_profiler", "SPDisplaysDataType")

	var out bytes.Buffer
	cmd.Stdout = &out
	err := cmd.Run()
	if err != nil {
		return GPUInfo{}, err
	}

	return parseGPUInfo(out.String())
}

// parseGPUInfo function: Parses the output from system_profiler to extract GPU info.
func parseGPUInfo(input string) (GPUInfo, error) {
	gpuInfo := GPUInfo{}

	for _, line := range strings.Split(input, "\n") {
		// Extracting relevant information from the output
		if strings.Contains(line, "Chipset Model") {
			gpuInfo.Model = strings.TrimSpace(strings.Split(line, ":")[1])
		}
		if strings.Contains(line, "Total Number of Cores") {
			gpuInfo.TotalNumberOfCores = strings.TrimSpace(strings.Split(line, ":")[1])
		}
		if strings.Contains(line, "Metal") {
			gpuInfo.MetalSupport = strings.TrimSpace(strings.Split(line, ":")[1])
		}
	}

	return gpuInfo, nil
}
--- END /Users/arturoaquino/Documents/eternal/host.go ---

--- BEGIN /Users/arturoaquino/Documents/eternal/projects.go ---
// projects.go

package main

import (
	"fmt"
	"os"
)

// CreateProject creates the resources associated with the project.
func (p *Project) CreateProjectFolder(config AppConfig) error {
	// Create the Project data in the database
	if err := sqliteDB.CreateProject(p); err != nil {
		return err
	}

	// Create the project folder
	projectPath := fmt.Sprintf("%s/projects/%s", config.DataPath, p.Name)
	return os.MkdirAll(projectPath, os.ModePerm)
}

// DeleteProject deletes all resources associated with the project.
func (p *Project) DeleteProject(config AppConfig) error {
	// Delete the Project data from the database
	if err := sqliteDB.DeleteProject(p.Name); err != nil {
		return err
	}

	// Delete the project folder
	projectPath := fmt.Sprintf("%s/projects/%s", config.DataPath, p.Name)
	return os.RemoveAll(projectPath)
}
--- END /Users/arturoaquino/Documents/eternal/projects.go ---

--- BEGIN /Users/arturoaquino/Documents/eternal/routes.go ---
// eternal/routes.go - API routes

package main

import (
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/websocket/v2"
)

// setupRoutes sets up the routes for the application
func setupRoutes(app *fiber.App, config *AppConfig, modelParams []ModelParams) {
	app.Get("/", func(c *fiber.Ctx) error {
		return c.Render("templates/index", fiber.Map{})
	})

	app.Get("/config", func(c *fiber.Ctx) error {
		return c.JSON(config)
	})

	app.Get("/flow", func(c *fiber.Ctx) error {
		return c.Render("templates/flow", fiber.Map{})
	})

	// Chat session routes
	app.Post("/chatsubmit", handleChatSubmit(config))
	app.Post("/chat/role/:name", handleRoleSelection(config))

	// Model management routes
	app.Post("/modelcards", handleModelCards(modelParams))
	app.Post("/model/select/:name/:action", handleModelSelect())
	app.Get("/model/selected", handleSelectedModels())
	app.Post("/model/download", handleModelDownload(config))
	app.Post("/imgmodel/download", handleImgModelDownload(config))
	app.Post("/model/set/params", handleModelUpdate())

	// Model - Database routes
	app.Get("/modeldata/:modelName", handleModelData())
	app.Put("/modeldata/:modelName/downloaded", handleModelDownloadUpdate())

	// Chat - Database routes
	app.Get("/chats", handleGetChats())
	app.Get("/chats/:id", handleGetChatByID())
	app.Put("/chats/:id", handleUpdateChat())
	app.Delete("/chats/:id", handleDeleteChat())

	// Tool routes
	app.Get("/tools/list", handleToolList(config))
	app.Post("/tool/:toolName/:enabled/:topN", handleToolToggle(config))
	app.Get("/dpsearch", handleDPSearch())

	// Utility routes
	// return the app config
	app.Post("/config", func(c *fiber.Ctx) error {
		return c.JSON(config)
	})
	app.Post("/upload", handleUpload(config))
	app.Get("/sseupdates", handleSSEUpdates())
	app.Get("/ws", websocket.New(handleWebSocket(config)))

	// OpenAI routes
	app.Get("/openai/models", handleOpenAIModels(config))
	app.Get("/wsoai", websocket.New(handleOpenAIWebSocket(config)))

	// Anthropic routes
	app.Get("/wsanthropic", websocket.New(handleAnthropicWebSocket(config)))

	// Google routes
	app.Get("/wsgoogle", websocket.New(handleGoogleWebSocket(config)))
}
--- END /Users/arturoaquino/Documents/eternal/routes.go ---

--- BEGIN /Users/arturoaquino/Documents/eternal/globals.go ---
// globals.go
package main

import (
	"github.com/blevesearch/bleve/v2"
	"github.com/spf13/afero"
)

var (
	devMode     bool     // If enabled, removes the database and search index on shutdown
	osFS        afero.Fs = afero.NewOsFs()
	chatTurn             = 1
	sqliteDB    *SQLiteDB
	searchIndex bleve.Index
)
--- END /Users/arturoaquino/Documents/eternal/globals.go ---

--- BEGIN /Users/arturoaquino/Documents/eternal/config_team.go ---
// config_team.go

package main

import (
	"gorm.io/gorm"
)

// Domain represents a knowledge domain or area of expertise
type Domain struct {
	ID          uint
	Name        string
	Description string
}

type ToolMemory struct {
	Enabled bool `yaml:"enabled"`
	TopN    int  `yaml:"top_n"`
}

type ToolWebGet struct {
	Enabled bool `yaml:"enabled"`
}

type ToolWebSearch struct {
	Enabled  bool   `yaml:"enabled"`
	Name     string `yaml:"name"`
	Endpoint string `yaml:"endpoint"`
	TopN     int    `yaml:"top_n"`
}

type ToolImgGen struct {
	Enabled bool `yaml:"enabled"`
}

type Tools struct {
	Memory    ToolMemory    `yaml:"memory"`
	WebGet    ToolWebGet    `yaml:"webget"`
	WebSearch ToolWebSearch `yaml:"websearch"`
	ImgGen    ToolImgGen    `yaml:"img_gen"`
}

// Role defines a template for an assistant's behavior
type Role struct {
	ID           uint
	Name         string
	Instructions string
	DomainID     uint   // Foreign key
	Domain       Domain `gorm:"foreignKey:DomainID"`
}

// LLMParams represents the configuration parameters for an LLM
type LLMParams struct {
	Model       string
	Temperature float64
	MaxTokens   int
}

// Assistant represents an LLM with its configuration and role
type Assistant struct {
	ID     uint
	Name   string
	RoleID uint
	Role   Role      `gorm:"foreignKey:RoleID"`
	Params LLMParams `gorm:"embedded"`
	TeamID uint      // Foreign key
}

// Team is a collection of assistants
type Team struct {
	ID         uint
	Name       string
	Assistants []Assistant `gorm:"foreignKey:TeamID"`
}

// Workflow represents the sequence and connections between assistants
type Workflow struct {
	ID          uint
	Name        string
	Description string
	Steps       []WorkflowStep `gorm:"foreignKey:WorkflowID"`
}

// WorkflowStep represents a single step in a workflow
type WorkflowStep struct {
	ID            uint
	WorkflowID    uint
	AssistantID   uint
	Order         int
	InputSources  []WorkflowStepSource `gorm:"foreignKey:StepID"`
	OutputTargets []WorkflowStepTarget `gorm:"foreignKey:StepID"`
}

// WorkflowStepSource represents the source steps for a WorkflowStep
type WorkflowStepSource struct {
	ID       uint
	StepID   uint
	SourceID uint
}

// WorkflowStepTarget represents the target steps for a WorkflowStep
type WorkflowStepTarget struct {
	ID       uint
	StepID   uint
	TargetID uint
}

// FileType is an enum for supported file types
type FileType int

const (
	TextFile FileType = iota
	MarkdownFile
	JSONFile
	PythonFile
	GoFile
	HTMLFile
	CSSFile
	JSFile
)

// File represents a file in the project
type File struct {
	gorm.Model
	Name      string
	Path      string
	Type      FileType
	Content   string
	ProjectID uint
}

// Project represents the overall configuration for a goal
type Project struct {
	gorm.Model
	Name        string
	Description string
	TeamID      uint
	Team        Team `gorm:"foreignKey:TeamID"`
	WorkflowID  uint
	Workflow    Workflow `gorm:"foreignKey:WorkflowID"`
	Files       []File   `gorm:"foreignKey:ProjectID"`
}

// Processor is an interface for objects that can process files
type Processor interface {
	Process(file File) error
}

// Inferencer is an interface for objects that can run inference
type Inferencer interface {
	RunInference(prompt string) (string, error)
}

// AssistantManager handles CRUD operations for assistants
type AssistantManager interface {
	CreateAssistant(assistant Assistant) error
	GetAssistant(id uint) (Assistant, error)
	UpdateAssistant(assistant Assistant) error
	DeleteAssistant(id uint) error
}

// ProjectManager handles CRUD operations for projects
type ProjectManager interface {
	CreateProject(project Project) error
	GetProject(id uint) (Project, error)
	UpdateProject(project Project) error
	DeleteProject(id uint) error
}
--- END /Users/arturoaquino/Documents/eternal/config_team.go ---

--- BEGIN /Users/arturoaquino/Documents/eternal/db.go ---
// db.go

package main

import (
	"errors"
	"eternal/pkg/llm"
	"eternal/pkg/sd"
	"fmt"
	"reflect"
	"time"

	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

type SQLiteDB struct {
	db *gorm.DB
}

// TEST
type ChatSession struct {
	ID        int64 `gorm:"primaryKey;autoIncrement"`
	CreatedAt time.Time
	UpdatedAt time.Time
	ChatTurns []ChatTurn `gorm:"foreignKey:SessionID"`
}

type ChatTurn struct {
	ID         int64 `gorm:"primaryKey;autoIncrement"`
	SessionID  int64
	UserPrompt string
	Responses  []ChatResponse `gorm:"foreignKey:TurnID"`
}

type ChatResponse struct {
	ID        int64 `gorm:"primaryKey;autoIncrement"`
	TurnID    int64
	Content   string
	Model     string // Identifier for the LLM model used
	Host      SystemInfo
	CreatedAt time.Time
}

type SystemInfo struct {
	OS     string `json:"os"`
	Arch   string `json:"arch"`
	CPUs   int    `json:"cpus"`
	Memory Memory `json:"memory"`
	GPUs   []GPU  `json:"gpus"`
}

type Memory struct {
	Total int64 `json:"total"`
}

type GPU struct {
	Model              string `json:"model"`
	TotalNumberOfCores string `json:"total_number_of_cores"`
	MetalSupport       string `json:"metal_support"`
}

// END TEST

type ModelParams struct {
	ID         int              `gorm:"primaryKey;autoIncrement"`
	Name       string           `yaml:"name"`
	Homepage   string           `yaml:"homepage"`
	GGUFInfo   string           `yaml:"gguf,omitempty"`
	Downloads  string           `yaml:"downloads,omitempty"`
	Downloaded bool             `yaml:"downloaded"`
	Options    *llm.GGUFOptions `gorm:"embedded"`
}

type ImageModel struct {
	ID         int          `gorm:"primaryKey;autoIncrement"`
	Name       string       `yaml:"name"`
	Homepage   string       `yaml:"homepage"`
	Prompt     string       `yaml:"prompt"`
	Downloads  string       `yaml:"downloads,omitempty"`
	Downloaded bool         `yaml:"downloaded"`
	Options    *sd.SDParams `gorm:"embedded"`
}

type SelectedModels struct {
	ID        int    `gorm:"primaryKey;autoIncrement"`
	ModelName string `json:"modelName"`
	Action    string `json:"action"`
}

type Chat struct {
	ID        int64 `gorm:"primaryKey;autoIncrement"`
	Prompt    string
	Response  string
	ModelName string
}

// type Project struct {
// 	gorm.Model
// 	Name  string
// 	Tools []ProjectTool `gorm:"foreignKey:ProjectID"`
// 	Files []File        `gorm:"foreignKey:ProjectID"`
// }

type ProjectTool struct {
	gorm.Model
	Name      string
	Enable    bool
	ProjectID uint // Foreign key that refers to Project
}

// type File struct {
// 	gorm.Model
// 	Path      string
// 	Content   string
// 	ProjectID uint // Foreign key that refers to Project
// }

// URLTracking represents the structure for tracking URLs
type URLTracking struct {
	ID  int64  `gorm:"primaryKey;autoIncrement"`
	URL string `gorm:"unique;not null"`
}

func NewSQLiteDB(dataPath string) (*SQLiteDB, error) {

	// Silence gorm logs during this step
	newLogger := logger.Default.LogMode(logger.Silent)

	dbPath := fmt.Sprintf("%s/eternaldata.db", dataPath)
	db, err := gorm.Open(sqlite.Open(dbPath), &gorm.Config{
		Logger: newLogger,
	})
	if err != nil {
		return nil, fmt.Errorf("error opening database: %v", err)
	}
	return &SQLiteDB{db: db}, nil
}

func (sqldb *SQLiteDB) AutoMigrate(models ...interface{}) error {
	for _, model := range models {
		if err := sqldb.db.AutoMigrate(model); err != nil {
			return fmt.Errorf("error migrating schema for %v: %v", reflect.TypeOf(model), err)
		}
	}
	return nil
}

// CreateProject inserts a new project into the database.
func (sqldb *SQLiteDB) CreateProject(project *Project) error {
	return sqldb.db.Create(project).Error
}

// DeleteProject removes a project from the database.
func (sqldb *SQLiteDB) DeleteProject(name string) error {
	return sqldb.db.Where("name = ?", name).Delete(&Project{}).Error
}

// ListProjects retrieves all projects from the database.
func (sqldb *SQLiteDB) ListProjects() ([]Project, error) {
	var projects []Project
	err := sqldb.db.Find(&projects).Error
	return projects, err
}

func (sqldb *SQLiteDB) Create(record interface{}) error {
	return sqldb.db.Create(record).Error
}

func (sqldb *SQLiteDB) Find(out interface{}) error {
	return sqldb.db.Find(out).Error
}

func (sqldb *SQLiteDB) First(name string, out interface{}) error {
	return sqldb.db.Where("name = ?", name).First(out).Error
}

func (sqldb *SQLiteDB) FindByID(id uint, out interface{}) error {
	return sqldb.db.First(out, id).Error
}

func (sqldb *SQLiteDB) UpdateByName(name string, updatedRecord interface{}) error {
	// Assuming 'Name' is the field in your model that holds the model's name.
	// The method first finds the record by name and then applies the updates.
	return sqldb.db.Model(updatedRecord).Where("name = ?", name).Updates(updatedRecord).Error
}

func (sqldb *SQLiteDB) UpdateDownloadedByName(name string, downloaded bool) error {
	return sqldb.db.Model(&ModelParams{}).Where("name = ?", name).Update("downloaded", downloaded).Error
}

func (sqldb *SQLiteDB) Delete(id uint, model interface{}) error {
	return sqldb.db.Delete(model, id).Error
}

func LoadModelDataToDB(db *SQLiteDB, models []ModelParams) error {
	for _, model := range models {
		var existingModel ModelParams
		result := db.db.Where("name = ?", model.Name).First(&existingModel)

		if result.Error != nil {
			if errors.Is(result.Error, gorm.ErrRecordNotFound) {
				// If the model is not found, create a new one
				if err := db.Create(&model); err != nil {
					return err
				}
			} else {
				// Other errors
				return result.Error
			}
		} else {
			// If the model exists, update it
			if err := db.db.Model(&existingModel).Updates(&model).Error; err != nil {
				return err
			}
		}
	}

	return nil
}

func LoadImageModelDataToDB(db *SQLiteDB, models []ImageModel) error {
	for _, model := range models {
		var existingModel ImageModel
		result := db.db.Where("name = ?", model.Name).First(&existingModel)

		if result.Error != nil {
			if errors.Is(result.Error, gorm.ErrRecordNotFound) {
				// If the model is not found, create a new one
				if err := db.Create(&model); err != nil {
					return err
				}
			} else {
				// Other errors
				return result.Error
			}
		} else {
			// If the model exists, update it
			if err := db.db.Model(&existingModel).Updates(&model).Error; err != nil {
				return err
			}
		}
	}

	return nil
}

func AddSelectedModel(db *gorm.DB, modelName string) error {
	// Remove any existing selected model from the database
	if err := db.Where("1 = 1").Delete(&SelectedModels{}).Error; err != nil {
		return err
	}

	// Create a new selected model
	selectedModel := SelectedModels{
		ModelName: modelName,
	}

	// Add the new selected model to the database
	return db.Create(&selectedModel).Error
}

func RemoveSelectedModel(db *gorm.DB, modelName string) error {
	return db.Where("model_name = ?", modelName).Delete(&SelectedModels{}).Error
}

func GetSelectedModels(db *gorm.DB) ([]SelectedModels, error) {
	var selectedModels []SelectedModels
	err := db.Find(&selectedModels).Error
	return selectedModels, err
}

// CreateChat inserts a new chat into the database.
func CreateChat(db *gorm.DB, prompt, response, model string) (Chat, error) {
	chat := Chat{Prompt: prompt, Response: response, ModelName: model}
	result := db.Create(&chat)
	return chat, result.Error
}

// GetChats retrieves all chat entries from the database.
func GetChats(db *gorm.DB) ([]Chat, error) {
	var chats []Chat
	result := db.Find(&chats)
	return chats, result.Error
}

// GetChatByID retrieves a chat by its ID.
func GetChatByID(db *gorm.DB, id int64) (Chat, error) {
	var chat Chat
	result := db.First(&chat, id)
	return chat, result.Error
}

// UpdateChat updates an existing chat entry in the database without changing its ID.
func UpdateChat(db *gorm.DB, id int64, newPrompt, newResponse, newModel string) error {
	result := db.Model(&Chat{}).Where("id = ?", id).Updates(Chat{Prompt: newPrompt, Response: newResponse, ModelName: newModel})
	return result.Error
}

// DeleteChat removes a chat entry from the database.
func DeleteChat(db *gorm.DB, id int64) error {
	result := db.Delete(&Chat{}, id)
	return result.Error
}

// CreateURLTracking inserts a new URL into the URLTracking table
func (sqldb *SQLiteDB) CreateURLTracking(url string) error {
	var existingURLTracking URLTracking

	// Check if the URL already exists in the table
	err := sqldb.db.Where("url = ?", url).First(&existingURLTracking).Error
	if err == nil {
		// URL already exists, return without inserting
		return nil
	} else if !errors.Is(err, gorm.ErrRecordNotFound) {
		// An error other than "record not found" occurred
		return err
	}

	// URL does not exist, proceed to insert
	urlTracking := URLTracking{URL: url}
	return sqldb.db.Create(&urlTracking).Error
}

// ListURLTrackings retrieves all URLs from the URLTracking table
func (sqldb *SQLiteDB) ListURLTrackings() ([]URLTracking, error) {
	var urlTrackings []URLTracking
	err := sqldb.db.Find(&urlTrackings).Error
	return urlTrackings, err
}

// DeleteURLTracking removes a URL from the URLTracking table
func (sqldb *SQLiteDB) DeleteURLTracking(url string) error {
	return sqldb.db.Where("url = ?", url).Delete(&URLTracking{}).Error
}

// UpdateModelDownloadedState updates the downloaded state of a model in the database.
// func UpdateModelDownloadedState(db *gorm.DB, dataPath string, modelName string, downloaded bool) error {
// 	db, err := NewSQLiteDB(dataPath)
// 	if err != nil {
// 		return fmt.Errorf("failed to open database: %w", err)
// 	}
// 	defer db.Close()

// 	err = db.UpdateDownloadedByName(modelName, downloaded)
// 	if err != nil {
// 		return fmt.Errorf("failed to update model downloaded state: %w", err)
// 	}

// 	return nil
// }
--- END /Users/arturoaquino/Documents/eternal/db.go ---

--- BEGIN /Users/arturoaquino/Documents/eternal/errors.go ---
// errors.go
package main

import "fmt"

// Custom error types
type ConfigError struct {
	Msg string
}

func (e *ConfigError) Error() string {
	return fmt.Sprintf("Config Error: %s", e.Msg)
}

type DatabaseError struct {
	Msg string
}

func (e *DatabaseError) Error() string {
	return fmt.Sprintf("Database Error: %s", e.Msg)
}

type NetworkError struct {
	Msg string
}

func (e *NetworkError) Error() string {
	return fmt.Sprintf("Network Error: %s", e.Msg)
}
--- END /Users/arturoaquino/Documents/eternal/errors.go ---

--- BEGIN /Users/arturoaquino/Documents/eternal/handlers_chat.go ---
package main

import (
	"bufio"
	"context"
	"encoding/json"
	"eternal/pkg/documents"
	"eternal/pkg/embeddings"
	"eternal/pkg/llm"
	"eternal/pkg/llm/anthropic"
	"eternal/pkg/llm/google"
	"eternal/pkg/llm/openai"
	"eternal/pkg/vecstore"
	"eternal/pkg/web"
	"fmt"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/blevesearch/bleve/v2"
	index "github.com/blevesearch/bleve_index_api"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/log"
	"github.com/gofiber/websocket/v2"
	"github.com/nlpodyssey/cybertron/pkg/models/bert"
	"github.com/nlpodyssey/cybertron/pkg/tasks"
	"github.com/nlpodyssey/cybertron/pkg/tasks/textencoding"
	"github.com/pterm/pterm"
	"github.com/valyala/fasthttp"
)

type ChatTurnMessage struct {
	ID       string `json:"id"`
	Prompt   string `json:"prompt"`
	Response string `json:"response"`
	Model    string `json:"model"`
}

// handleChatSubmit handles the submission of chat messages.
func handleChatSubmit(config *AppConfig) fiber.Handler {
	return func(c *fiber.Ctx) error {
		userPrompt := c.FormValue("userprompt")
		var wsroute string

		selectedModels, err := GetSelectedModels(sqliteDB.db)
		if err != nil {
			log.Errorf("Error getting selected models: %v", err)
			return c.Status(500).SendString("Server Error")
		}

		if len(selectedModels) > 0 {
			firstModelName := selectedModels[0].ModelName

			if strings.HasPrefix(firstModelName, "openai-") {
				wsroute = "/wsoai"
			} else if strings.HasPrefix(firstModelName, "google-") {
				wsroute = "/wsgoogle"
			} else if strings.HasPrefix(firstModelName, "anthropic-") {
				wsroute = "/wsanthropic"
			} else {
				wsroute = fmt.Sprintf("ws://%s:%s/ws", config.ServiceHosts["llm"]["llm_host_1"].Host, config.ServiceHosts["llm"]["llm_host_1"].Port)
			}
		} else {
			return c.JSON(fiber.Map{"error": "No models selected"})
		}

		turnID := IncrementTurn()

		return c.Render("templates/chat", fiber.Map{
			"username":  config.CurrentUser,
			"message":   userPrompt,
			"assistant": config.AssistantName,
			"model":     selectedModels[0].ModelName,
			"turnID":    turnID,
			"wsRoute":   wsroute,
			"hosts":     config.ServiceHosts["llm"],
		})
	}
}

// handleGetChats retrieves and returns all chat records.
func handleGetChats() fiber.Handler {
	return func(c *fiber.Ctx) error {
		chats, err := GetChats(sqliteDB.db)
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "could not get chats"})
		}
		return c.Status(fiber.StatusOK).JSON(chats)
	}
}

// handleGetChatByID retrieves and returns a chat record by its ID.
func handleGetChatByID() fiber.Handler {
	return func(c *fiber.Ctx) error {
		id, err := strconv.ParseInt(c.Params("id"), 10, 64)
		if err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "invalid id"})
		}

		chat, err := GetChatByID(sqliteDB.db, id)
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "could not get chat"})
		}
		return c.Status(fiber.StatusOK).JSON(chat)
	}
}

// handleUpdateChat updates a chat record by its ID.
func handleUpdateChat() fiber.Handler {
	return func(c *fiber.Ctx) error {
		id, err := strconv.ParseInt(c.Params("id"), 10, 64)
		if err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "invalid id"})
		}

		chat := new(Chat)
		if err := c.BodyParser(chat); err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "cannot parse JSON"})
		}

		err = UpdateChat(sqliteDB.db, id, chat.Prompt, chat.Response, chat.ModelName)
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "could not update chat"})
		}
		return c.SendStatus(fiber.StatusNoContent)
	}
}

// handleDeleteChat handles the deletion of a chat by its ID.
func handleDeleteChat() fiber.Handler {
	return func(c *fiber.Ctx) error {
		// Parse the chat ID from the request parameters.
		id, err := strconv.ParseInt(c.Params("id"), 10, 64)
		if err != nil {
			// Return a bad request status if the ID is invalid.
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "invalid id"})
		}

		// Attempt to delete the chat from the database.
		err = DeleteChat(sqliteDB.db, id)
		if err != nil {
			// Return an internal server error status if the deletion fails.
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "could not delete chat"})
		}
		// Return a no content status if the deletion is successful.
		return c.SendStatus(fiber.StatusNoContent)
	}
}

// handleListProjects retrieves and returns a list of projects from the database.
func handleListProjects() fiber.Handler {
	return func(c *fiber.Ctx) error {
		projects, err := sqliteDB.ListProjects()
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "could not get projects"})
		}
		return c.Status(fiber.StatusOK).JSON(projects)
	}
}

// handleUpload handles file uploads and saves them to the specified directory.
func handleUpload(config *AppConfig) fiber.Handler {
	return func(c *fiber.Ctx) error {
		pterm.Warning.Println("Uploads route hit")

		form, err := c.MultipartForm()
		if err != nil {
			return err
		}

		files := form.File["file"]
		for _, file := range files {
			filename := filepath.Join(config.DataPath, "web", "uploads", file.Filename)
			pterm.Warning.Printf("Uploading file: %s\n", filename)
			if err := c.SaveFile(file, filename); err != nil {
				return err
			}
			log.Infof("Uploaded file %s to %s", file.Filename, filename)

			// If the file is a pdf, extract the text content and print it as Markdown.
			if strings.HasSuffix(file.Filename, ".pdf") {
				pdfDoc, err := documents.GetPdfContents(filename)
				if err != nil {
					pterm.Error.Println(err)
				}

				err = searchIndex.Index(file.Filename, pdfDoc)
				if err != nil {
					log.Errorf("Error storing chat message in Bleve: %v", err)
				}

				return c.JSON(fiber.Map{"file": file.Filename, "content": pdfDoc})
			}
		}

		// return the file path of all the documents uploaded
		return c.JSON(fiber.Map{"files": files})
	}
}

// handleDPSearch handles search requests using DuckDuckGo.
func handleDPSearch() fiber.Handler {
	return func(c *fiber.Ctx) error {
		// Retrieve the search query from the request.
		query := c.Query("q")
		res := web.SearchDDG(query)

		// Return an internal server error status if no results are found.
		if len(res) == 0 {
			return c.Status(fiber.StatusInternalServerError).SendString("Error retrieving search results")
		}

		// Return the search results as a JSON response.
		urls := res
		return c.Status(fiber.StatusOK).JSON(fiber.Map{"urls": urls})
	}
}

// handleSSEUpdates handles Server-Sent Events (SSE) for updates.
func handleSSEUpdates() fiber.Handler {
	return func(c *fiber.Ctx) error {
		// Set the necessary headers for SSE.
		c.Set("Content-Type", "text/event-stream")
		c.Set("Cache-Control", "no-cache")
		c.Set("Connection", "keep-alive")
		c.Set("Transfer-Encoding", "chunked")

		// Write updates to the response stream.
		c.Context().SetBodyStreamWriter(fasthttp.StreamWriter(func(w *bufio.Writer) {
			for {
				// Get the current download progress.
				progress := llm.GetDownloadProgress("sse-progress")
				msg := fmt.Sprintf("data: <div class='progress specific-h-25 m-4' role='progressbar' aria-label='download' aria-valuenow='%s' aria-valuemin='0' aria-valuemax='100'><div class='progress-bar progress-bar-striped progress-bar-animated' style='width: %s;'></div></div><div class='text-center fs-6'>Please refresh this page when the download completes.</br> Downloading...%s</div>\n\n", progress, progress, progress)

				// Write the progress message to the stream.
				if _, err := w.WriteString(msg); err != nil {
					pterm.Printf("Error writing to stream: %v", err)
					break
				}
				// Flush the writer to ensure the message is sent.
				if err := w.Flush(); err != nil {
					pterm.Printf("Error flushing writer: %v", err)
					break
				}

				// Sleep for 2 seconds before sending the next update.
				time.Sleep(2 * time.Second)
			}
		}))

		return nil
	}
}

// handleWebSocket handles WebSocket connections for general use.
func handleWebSocket(config *AppConfig) func(*websocket.Conn) {
	return func(c *websocket.Conn) {
		handleWebSocketConnection(c, config, func(wsMessage WebSocketMessage, chatMessage string) error {
			var model ModelParams
			// Retrieve the model parameters from the database.
			err := sqliteDB.First(wsMessage.Model, &model)
			if err != nil {
				log.Errorf("Error getting model %s: %v", wsMessage.Model, err)
				return err
			}

			// Prepare the full prompt for the model.
			promptTemplate := model.Options.Prompt

			fullInstructions := fmt.Sprintf("%s\n\n%s", config.CurrentRoleInstructions, chatMessage)

			fullPrompt := strings.ReplaceAll(promptTemplate, "{prompt}", fullInstructions)
			fullPrompt = strings.ReplaceAll(fullPrompt, "{system}", "You are a helpful AI assistant.")

			// Set the model options.
			// repeatPenalty := 1.1
			// temperature := 0.2
			// tp := 0.95
			// tk := 40

			// If any of the tools are enabled, lower the RepeatPenalty to 1.0
			// if config.Tools.ImgGen.Enabled || config.Tools.Memory.Enabled || config.Tools.WebGet.Enabled || config.Tools.WebSearch.Enabled {
			// 	temperature = 0.2
			// 	repeatPenalty = 1.0 // 1.0 = disabled
			// 	tp = 0.95
			// 	tk = 40
			// }

			// Set the model options.
			modelOpts := &llm.GGUFOptions{
				NGPULayers:    config.ServiceHosts["llm"]["llm_host_1"].GgufGPULayers,
				Model:         model.Options.Model,
				Prompt:        fullPrompt,
				CtxSize:       model.Options.CtxSize,
				Temp:          model.Options.Temp,
				RepeatPenalty: model.Options.RepeatPenalty,
				TopP:          model.Options.TopP,
				TopK:          model.Options.TopK,
			}

			// Make a completion request to the model and send the response over WebSocket.
			return llm.MakeCompletionWebSocket(*c, chatTurn, modelOpts, config.DataPath)
		})
	}
}

// handleOpenAIWebSocket handles WebSocket connections for OpenAI.
func handleOpenAIWebSocket(config *AppConfig) func(*websocket.Conn) {
	return func(c *websocket.Conn) {
		handleWebSocketConnection(c, config, func(wsMessage WebSocketMessage, chatMessage string) error {
			// Get the system template for the chat message.
			cpt := llm.GetSystemTemplate(chatMessage)
			// Stream the completion response from OpenAI to the WebSocket.
			return openai.StreamCompletionToWebSocket(c, chatTurn, "gpt-4o", cpt.Messages, 0.3, config.OAIKey)
		})
	}
}

// handleAnthropicWS handles WebSocket connections for Anthropic.
func handleAnthropicWS(c *websocket.Conn, apiKey string, chatID int) {
	// Read the initial message from the WebSocket.
	_, message, err := c.ReadMessage()
	if err != nil {
		pterm.PrintOnError(err)
		return
	}

	// Unmarshal the JSON message.
	var wsMessage WebSocketMessage
	err = json.Unmarshal(message, &wsMessage)
	if err != nil {
		c.WriteMessage(websocket.TextMessage, []byte("Error unmarshalling JSON"))
		return
	}

	// Extract the chat message value.
	chatMessage := wsMessage.ChatMessage

	// Prepare the messages for the completion request.
	messages := []anthropic.Message{
		{Role: "user", Content: chatMessage},
	}

	// Stream the completion response from Anthropic to the WebSocket.
	res := anthropic.StreamCompletionToWebSocket(c, chatID, "claude-3-5-sonnet-20240620", messages, 0.3, apiKey)
	if res != nil {
		pterm.Error.Println("Error in anthropic completion:", res)
	}

	// Increment the chat turn counter.
	chatTurn = chatTurn + 1
}

// handleAnthropicWebSocket handles WebSocket connections for Anthropic.
func handleAnthropicWebSocket(config *AppConfig) func(*websocket.Conn) {
	return func(c *websocket.Conn) {
		apiKey := config.AnthropicKey
		handleAnthropicWS(c, apiKey, chatTurn)
	}
}

// handleGoogleWebSocket handles WebSocket connections for Google.
func handleGoogleWebSocket(config *AppConfig) func(*websocket.Conn) {
	return func(c *websocket.Conn) {
		apiKey := config.GoogleKey

		handleWebSocketConnection(c, config, func(wsMessage WebSocketMessage, chatMessage string) error {
			// Stream the Gemini response from Google to the WebSocket.
			return google.StreamGeminiResponseToWebSocket(c, chatTurn, chatMessage, apiKey)
		})
	}
}

// handleWebSocketConnection handles the common logic for WebSocket connections.
func handleWebSocketConnection(c *websocket.Conn, config *AppConfig, processMessage func(WebSocketMessage, string) error) {
	for {
		// Read and unmarshal the WebSocket message.
		wsMessage, err := readAndUnmarshalMessage(c)
		if err != nil {
			log.Errorf("Error reading or unmarshalling message: %v", err)
			return
		}

		log.Infof("Received WebSocket message: %+v", wsMessage)

		chatMessage := wsMessage.ChatMessage

		// Only perform the tool workflow if any of the tools are enabled.
		if config.Tools.ImgGen.Enabled || config.Tools.Memory.Enabled || config.Tools.WebGet.Enabled || config.Tools.WebSearch.Enabled {

			// Perform the tool workflow on the chat message.
			chatMessage = performToolWorkflow(c, config, wsMessage.ChatMessage)
		}

		log.Infof("Processed chat message: %s", chatMessage)

		// Process the WebSocket message.
		err = processMessage(wsMessage, chatMessage)
		if err != nil {
			handleError(config, wsMessage, err)
			return
		}

		log.Info("Message processed successfully")
	}
}

// readAndUnmarshalMessage reads and unmarshals a WebSocket message.
func readAndUnmarshalMessage(c *websocket.Conn) (WebSocketMessage, error) {
	// Read the message from the WebSocket.
	_, messageBytes, err := c.ReadMessage()
	if err != nil {
		return WebSocketMessage{}, err
	}

	// Unmarshal the JSON message.
	var wsMessage WebSocketMessage
	err = json.Unmarshal(messageBytes, &wsMessage)
	if err != nil {
		return WebSocketMessage{}, err
	}

	return wsMessage, nil
}

// handleError handles errors that occur during message processing.
func handleError(config *AppConfig, message WebSocketMessage, err error) {
	log.Errorf("Chat turn finished: %v", err)

	// Store the chat turn in the sqlite db.
	if _, err := CreateChat(sqliteDB.db, message.ChatMessage, err.Error(), message.Model); err != nil {
		pterm.Error.Println("Error storing chat in database:", err)
		return
	}

	if config.Tools.Memory.Enabled {

		// Get the timestamp for the chat message in human-readable format.
		timestamp := time.Now().Format("2006-01-02 15:04:05")

		memHeader := fmt.Sprintf("Previous chat - %s", timestamp)

		// Two examples of how to store chat messages in the Bleve index.
		// 1. Split the text and store each chunk in the index.
		// 2. Store the entire chat message in the index.
		// Split the chat message into chunks 500 characters long with a 200 character overlap.
		chunks := documents.SplitTextByCount(err.Error(), 500)

		// Prepend the header to all chunks.
		for i, chunk := range chunks {
			chunks[i] = fmt.Sprintf("%s\n%s", memHeader, chunk)
		}

		// 1. Store the chunk in Bleve.
		for _, chunk := range chunks {
			chatMessage := ChatTurnMessage{
				ID:       fmt.Sprintf("%d", time.Now().UnixNano()),
				Prompt:   message.ChatMessage,
				Response: chunk,
				Model:    message.Model,
			}

			err = searchIndex.Index(chatMessage.ID, chatMessage)
			if err != nil {
				log.Errorf("Error storing chat message in Bleve: %v", err)
			}
		}
		// 2. Store the entire chat message in Bleve.
		// chatMessage := ChatTurnMessage{
		// 	ID:       fmt.Sprintf("%d", time.Now().UnixNano()),
		// 	Prompt:   message.ChatMessage,
		// 	Response: err.Error(),
		// 	Model:    message.Model,
		// }

		// err = searchIndex.Index(chatMessage.ID, chatMessage)
		// if err != nil {
		// 	log.Errorf("Error storing chat message in Bleve: %v", err)
		// }
	}

	// Increment the chat turn counter.
	chatTurn++
}

// handleChatMemory retrieves and returns chat memory.
func handleChatMemory(config *AppConfig, chatMessage string) (string, error) {
	var document string

	topN := config.Tools.Memory.TopN

	// Create a search query
	query := bleve.NewQueryStringQuery(chatMessage)

	// Create a search request with the query and limit the results
	searchRequest := bleve.NewSearchRequestOptions(query, topN, 0, false)

	// Execute the search
	searchResults, err := searchIndex.Search(searchRequest)
	if err != nil {
		log.Errorf("Error searching index: %v", err)
		return "", err
	}

	// Print the search results
	for _, hit := range searchResults.Hits {
		doc, err := searchIndex.Document(hit.ID)
		if err != nil {
			log.Errorf("Error retrieving document: %v", err)
			continue
		}

		doc.VisitFields(func(field index.Field) {
			//fmt.Printf("%s: %s\n", field.Name(), field.Value())

			// Append the response field to the document and store it for later use
			if field.Name() == "response" {
				document = fmt.Sprintf("%s\n%s", document, field.Value())
			}
		})
	}

	modelPath := filepath.Join(config.DataPath, "models/HF/avsolatorio/GIST-small-Embedding-v0/avsolatorio/GIST-small-Embedding-v0")
	embeddings.GenerateEmbeddingForTask("chat", document, "txt", 4096, 1024, modelPath)

	searchRes := searchSimilarEmbeddings(config, "GIST-small-Embedding-v0", modelPath, chatMessage, topN)

	// Retrieve the most similar chunks of text from the chat embeddings
	for _, res := range searchRes {

		similarity := res.Similarity
		if similarity > 0.8 {
			//pterm.Info.Println("Most similar chunk of text:")
			//pterm.Info.Println(res.Word)
			document = fmt.Sprintf("%s\n%s", document, res.Word)
		}
	}

	return document, nil
}

// storeChat stores a chat in the database and generates embeddings for it.
// func storeChat(config *AppConfig, prompt string, response string) error {
// 	// Generate embeddings for the chat.
// 	pterm.Warning.Println("Generating embeddings for chat...")

// 	chatText := fmt.Sprintf("QUESTION: %s\n RESPONSE: %s", prompt, response)
// 	err := embeddings.GenerateEmbeddingForTask("chat", chatText, "txt", 500, 100, config.DataPath)
// 	if err != nil {
// 		pterm.Error.Println("Error generating embeddings:", err)
// 		return err
// 	}

// 	return nil
// }

// handleTextSplitAndIndex handles the splitting and indexing of text.
func handleTextSplitAndIndex(inputTags string, inputText string, chunkSize int, modelName string) error {
	// Split the input text into chunks.
	chunks := documents.SplitTextByCount(inputText, chunkSize)

	// Prepend the input tags to each chunk.
	for i, chunk := range chunks {
		chunks[i] = fmt.Sprintf("TAGS: [%s]\n%s", inputTags, chunk)
	}

	var wg sync.WaitGroup

	for _, chunk := range chunks {
		wg.Add(1)

		go func(c string) {
			defer wg.Done()

			docID := fmt.Sprintf("%d", time.Now().UnixNano())
			doc := ChatTurnMessage{
				ID:       docID,
				Prompt:   inputText,
				Response: c,
				Model:    modelName,
			}

			if err := searchIndex.Index(docID, doc); err != nil {
				log.Errorf("Error indexing chunk in Bleve: %v", err)
			}
		}(chunk)
	}

	wg.Wait()

	return nil
}

// searchSimilarEmbeddings searches for similar embeddings in the database.
func searchSimilarEmbeddings(config *AppConfig, modelName string, modelPath string, prompt string, topN int) []vecstore.Embedding {
	db := vecstore.NewEmbeddingDB()
	dbPath := fmt.Sprintf("%s/embeddings.db", config.DataPath)
	embeddings, err := db.LoadEmbeddings(dbPath)
	if err != nil {
		fmt.Println("Error loading embeddings:", err)
		return nil
	}

	model, err := tasks.Load[textencoding.Interface](&tasks.Config{ModelsDir: modelPath, ModelName: modelName})
	if err != nil {
		fmt.Println("Error loading model:", err)
		return nil
	}

	var vec []float64
	result, err := model.Encode(context.Background(), prompt, int(bert.MeanPooling))
	if err != nil {
		fmt.Println("Error encoding text:", err)
		return nil
	}
	vec = result.Vector.Data().F64()[:128]

	embeddingForPrompt := vecstore.Embedding{
		Word:       prompt,
		Vector:     vec,
		Similarity: 0.0,
	}

	// Retrieve the top N similar embeddings
	topEmbeddings := vecstore.FindTopNSimilarEmbeddings(embeddingForPrompt, embeddings, topN)
	if len(topEmbeddings) == 0 {
		fmt.Println("Error finding similar embeddings.")
		return nil
	}

	return topEmbeddings
}

// ToolState represents the state of a tool.
type ToolState struct {
	Tool    string `json:"tool"`
	Enabled bool   `json:"enabled"`
}
--- END /Users/arturoaquino/Documents/eternal/handlers_chat.go ---

--- BEGIN /Users/arturoaquino/Documents/eternal/main.go ---
// eternal/main.go - Main entry point for the Eternal application

package main

import (
	"context"
	"embed"
	"errors"
	"eternal/pkg/llm"
	"eternal/pkg/sd"
	"flag"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"

	"github.com/blevesearch/bleve/v2"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/log"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/gofiber/fiber/v2/middleware/filesystem"
	"github.com/gofiber/template/html/v2"
	"github.com/pterm/pterm"
	"github.com/pterm/pterm/putils"
	"github.com/spf13/afero"
)

// Embed static files and binaries
//
//go:embed public/* pkg/llm/local/bin/* pkg/sd/sdcpp/build/bin/*
var embedfs embed.FS

// WebSocketMessage represents the structure of a WebSocket message
type WebSocketMessage struct {
	ChatMessage string                 `json:"chat_message"`
	Model       string                 `json:"model"`
	Headers     map[string]interface{} `json:"HEADERS"`
}

// Tool represents a tool with its name and enabled status
type Tool struct {
	Name    string `json:"name"`
	Enabled bool   `json:"enabled"`
}

func main() {
	flag.BoolVar(&devMode, "devmode", false, "Run the application in development mode")
	flag.Parse()

	displayBanner()

	// DISABLED due to bug in CUDA
	// Print host information as pterm table
	// hostInfo, err := GetHostInfo()
	// if err != nil {
	// 	pterm.Error.Println("Error getting host information:", err)
	// } else {
	// 	// Convert memory to GB
	// 	hostInfo.Memory.Total = hostInfo.Memory.Total / 1024 / 1024 / 1024
	// 	// Convert ints to strings for pterm table
	// 	pterm.DefaultTable.WithData(pterm.TableData{
	// 		{"OS", hostInfo.OS},
	// 		{"Architecture", hostInfo.Arch},
	// 		{"CPU Cores", fmt.Sprintf("%d", hostInfo.CPUs)},
	// 		{"Memory (GB)", fmt.Sprintf("%d", hostInfo.Memory.Total)},
	// 		{"GPU Model", hostInfo.GPUs[0].Model},
	// 		{"GPU Cores", hostInfo.GPUs[0].TotalNumberOfCores},
	// 		{"Metal Support", hostInfo.GPUs[0].MetalSupport},
	// 	}).Render()
	// }

	// Load configuration
	config, err := loadConfig()
	if err != nil {
		pterm.Error.Println("Error loading config:", err)
		os.Exit(1)
	}

	// Set defaults
	// Set default assistant role
	config.CurrentRoleInstructions = config.AssistantRoles[0].Instructions

	// Initialize tools based on config
	tools := initializeTools(config)

	// If the tool is enabled, print the tool name
	for _, tool := range tools {
		if tool.Enabled {
			pterm.Info.Println("Enabled tool:", tool.Name)
		}
	}

	// Create data directory if it doesn't exist
	if err := createDataDirectory(config.DataPath); err != nil {
		pterm.Error.Println("Error creating data directory:", err)
		os.Exit(1)
	} else {
		// Delete all of the files in the web/public/tmp directory
		tmpDir := filepath.Join(config.DataPath, "web", "public", "tmp")
		if err := os.RemoveAll(tmpDir); err != nil {
			pterm.Error.Println("Error deleting tmp directory:", err)
		}
	}

	// Initialize server
	if err := initializeServer(config.DataPath); err != nil {
		pterm.Error.Println("Error initializing server:", err)
		os.Exit(1)
	}

	// Initialize database
	if err := initializeDatabase(config.DataPath); err != nil {
		pterm.Error.Println("Failed to initialize database:", err)
		os.Exit(1)
	}

	// Initialize search index
	if err := initializeSearchIndex(config.DataPath); err != nil {
		pterm.Error.Println("Failed to initialize search index:", err)
		os.Exit(1)
	}

	// Load model parameters
	modelParams, err := loadModelParams(config)
	if err != nil {
		pterm.Error.Println("Failed to load model data to database:", err)
		os.Exit(1)
	}

	// Prepare data for the pterm table including headers
	tableData := pterm.TableData{
		{"Model Name", "Context Size", "Downloaded"},
	}

	// Loop through model parameters and add each to the table
	for _, param := range modelParams {
		tableData = append(tableData, []string{param.Name, fmt.Sprintf("%d", param.Options.CtxSize), fmt.Sprintf("%t", param.Downloaded)})
	}

	// Print the model parameters as a pterm table
	pterm.DefaultTable.WithData(tableData).WithHasHeader().WithStyle(pterm.NewStyle(pterm.FgCyan)).Render()

	// Load image models
	imageModels, err := loadImageModels(config)
	if err != nil {
		pterm.Error.Println("Failed to load image model data to database:", err)
		os.Exit(1)
	}

	// Print the name of the image model
	for _, model := range imageModels {
		pterm.Info.Println("Image model:", model.Name)
	}

	// Setup context for graceful shutdown
	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	pterm.Info.Printf("Serving frontend on: %s:%s\n", config.ControlHost, config.ControlPort)
	pterm.Info.Println("Press Ctrl+C to stop")

	// Run frontend server
	runFrontendServer(ctx, config, modelParams)

	pterm.Warning.Println("Shutdown signal received")
	os.Exit(0)
}

// displayBanner displays the application banner
func displayBanner() {
	_ = pterm.DefaultBigText.WithLetters(putils.LettersFromString("ETERNAL")).Render()
}

// loadConfig loads the application configuration from a file
func loadConfig() (*AppConfig, error) {
	currentPath, err := os.Getwd()
	if err != nil {
		return nil, fmt.Errorf("error getting current path: %w", err)
	}

	configPath := filepath.Join(currentPath, "config.yml")
	pterm.Info.Println("Loading config:", configPath)

	return LoadConfig(osFS, configPath)
}

// initializeTools initializes the tools based on the configuration
func initializeTools(config *AppConfig) []Tool {
	var tools []Tool
	if config.Tools.WebGet.Enabled {
		tools = append(tools, Tool{Name: "webget", Enabled: true})
	}
	if config.Tools.WebSearch.Enabled {
		tools = append(tools, Tool{Name: "websearch", Enabled: true})
	}
	return tools
}

// createDataDirectory creates the data directory if it doesn't exist
func createDataDirectory(dataPath string) error {
	if _, err := os.Stat(dataPath); os.IsNotExist(err) {
		return os.Mkdir(dataPath, 0755)
	}
	return nil
}

// initializeServer initializes the server
func initializeServer(dataPath string) error {
	_, err := InitServer(dataPath)
	return err
}

// initializeDatabase initializes the SQLite database
func initializeDatabase(dataPath string) error {
	var err error
	sqliteDB, err = NewSQLiteDB(dataPath)
	if err != nil {
		return err
	}

	return sqliteDB.AutoMigrate(&Project{}, &ModelParams{}, &ImageModel{}, &SelectedModels{}, &Chat{}, &URLTracking{})
}

// initializeSearchIndex initializes the search index
func initializeSearchIndex(dataPath string) error {
	searchDB := fmt.Sprintf("%s/search.bleve", dataPath)

	if _, err := os.Stat(searchDB); os.IsNotExist(err) {
		mapping := bleve.NewIndexMapping()
		searchIndex, err = bleve.New(searchDB, mapping)
		if err != nil {
			return err
		}
	} else {
		searchIndex, err = bleve.Open(searchDB)
		if err != nil {
			return err
		}
	}
	return nil
}

// loadModelParams loads the model parameters from the configuration
func loadModelParams(config *AppConfig) ([]ModelParams, error) {
	var modelParams []ModelParams
	for _, model := range config.LanguageModels {
		if model.Downloads != nil {
			fileName := strings.Split(model.Downloads[0], "/")
			model.LocalPath = fmt.Sprintf("%s/models/%s/%s", config.DataPath, model.Name, fileName[len(fileName)-1])
		}

		var downloaded bool
		if _, err := os.Stat(model.LocalPath); err == nil {
			downloaded = true
		}

		modelParams = append(modelParams, ModelParams{
			Name:       model.Name,
			Homepage:   model.Homepage,
			GGUFInfo:   model.GGUF,
			Downloaded: downloaded,
			Options: &llm.GGUFOptions{
				Model:         model.LocalPath,
				Prompt:        model.Prompt,
				CtxSize:       model.Ctx,
				Temp:          0.7,
				RepeatPenalty: 1.1,
			},
		})
	}

	if err := LoadModelDataToDB(sqliteDB, modelParams); err != nil {
		return nil, err
	}
	return modelParams, nil
}

// loadImageModels loads the image models from the configuration
func loadImageModels(config *AppConfig) ([]ImageModel, error) {
	var imageModels []ImageModel
	for _, model := range config.ImageModels {
		if model.Downloads != nil {
			fileName := strings.Split(model.Downloads[0], "/")
			model.LocalPath = fmt.Sprintf("%s/models/%s/%s", config.DataPath, model.Name, fileName[len(fileName)-1])
		}

		var downloaded bool
		if _, err := os.Stat(model.LocalPath); err == nil {
			downloaded = true
		}

		imageModels = append(imageModels, ImageModel{
			Name:       model.Name,
			Homepage:   model.Homepage,
			Prompt:     model.Prompt,
			Downloaded: downloaded,
			Options: &sd.SDParams{
				Model:  model.LocalPath,
				Prompt: model.Prompt,
			},
		})
	}

	if err := LoadImageModelDataToDB(sqliteDB, imageModels); err != nil {
		return nil, err
	}
	return imageModels, nil
}

// runFrontendServer runs the frontend server
func runFrontendServer(ctx context.Context, config *AppConfig, modelParams []ModelParams) {
	basePath := filepath.Join(config.DataPath, "web")
	baseFs := afero.NewBasePathFs(afero.NewOsFs(), basePath)
	httpFs := afero.NewHttpFs(baseFs)
	engine := html.NewFileSystem(httpFs, ".html")

	app := fiber.New(fiber.Config{
		AppName:               "Eternal v0.1.0",
		BodyLimit:             100 * 1024 * 1024, // 100MB, to allow for larger file uploads
		DisableStartupMessage: true,
		ServerHeader:          "Eternal",
		PassLocalsToViews:     true,
		Views:                 engine,
		StrictRouting:         true,
		StreamRequestBody:     true,
	})

	// Setup CORS middleware
	app.Use(cors.New(cors.Config{
		AllowOrigins: "*",
		AllowHeaders: "*",
	}))

	// Serve static files
	app.Use("/public", filesystem.New(filesystem.Config{
		Root:   httpFs,
		Index:  "index.html",
		Browse: true,
	}))

	app.Static("/", "public")

	// Setup routes
	setupRoutes(app, config, modelParams)

	// Handle graceful shutdown
	go func() {
		<-ctx.Done() // Wait for the context to be cancelled

		if devMode {
			// delete the search index and database
			if err := os.RemoveAll(filepath.Join(config.DataPath, "search.bleve")); err != nil {
				log.Fatalf("Failed to delete search index: %v", err)
			}

			if err := os.RemoveAll(filepath.Join(config.DataPath, "eternaldata.db")); err != nil {
				log.Fatalf("Failed to delete database: %v", err)
			}

			// Loop through the config models and delete the cache
			for _, model := range modelParams {
				if model.Downloaded {
					cachePath := filepath.Join(config.DataPath, "models", model.Name, "cache")

					// First check if the cache file exists
					if _, err := os.Stat(cachePath); err == nil {
						pterm.Warning.Printf("Deleting cache: %s\n", cachePath)

						if err := os.RemoveAll(cachePath); err != nil {
							log.Fatalf("Failed to delete cache: %v", err)
						}
					}
				}
			}
		}

		if err := app.Shutdown(); err != nil {
			log.Fatalf("Server shutdown failed: %v", err)
		}
	}()

	addr := fmt.Sprintf("%s:%s", config.ControlHost, config.ControlPort)
	if err := app.Listen(addr); err != nil && !errors.Is(err, http.ErrServerClosed) {
		log.Fatalf("Frontend server failed: %v", err)
	}

	pterm.Info.Println("Server gracefully shutdown")
}
--- END /Users/arturoaquino/Documents/eternal/main.go ---

--- BEGIN /Users/arturoaquino/Documents/eternal/config.go ---
// eternal/config.go

package main

import (
	"embed"
	"eternal/pkg/llm"
	"eternal/pkg/sd"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"sync/atomic"
	"time"

	"github.com/gofiber/fiber/v2/log"
	"github.com/spf13/afero"
	"gopkg.in/yaml.v3"
	"gorm.io/gorm"
)

var (
	LocalFs        = new(afero.OsFs)
	MemFs          = afero.NewMemMapFs()
	messageCounter int64
)

type AppConfig struct {
	ServerID                string                            `yaml:"server_id"`
	CurrentUser             string                            `yaml:"current_user"`
	AssistantName           string                            `yaml:"assistant_name"`
	ControlHost             string                            `yaml:"control_host"`
	ControlPort             string                            `yaml:"control_port"`
	DataPath                string                            `yaml:"data_path"`
	ServiceHosts            map[string]map[string]BackendHost `yaml:"service_hosts"`
	ChromedpKey             string                            `yaml:"chromedp_key"`
	OAIKey                  string                            `yaml:"oai_key"`
	AnthropicKey            string                            `yaml:"anthropic_key"`
	GoogleKey               string                            `yaml:"google_key"`
	LanguageModels          []llm.Model                       `yaml:"language_models"`
	ImageModels             []sd.ImageModel                   `yaml:"image_models"`
	CurrentRoleInstructions string                            `yaml:"current_role"`
	AssistantRoles          []struct {
		Name         string `yaml:"name"`
		Instructions string `yaml:"instructions"`
	} `yaml:"assistant_roles"`
	Tools Tools `yaml:"tools"`
}

// BackendHost represents a local or remote backend host.
type BackendHost struct {
	ID            uint           `gorm:"primaryKey" yaml:"-"`
	Host          string         `yaml:"host" gorm:"column:host"`
	Port          string         `yaml:"port" gorm:"column:port"`
	GgufGPULayers int            `yaml:"gpu_layers" gorm:"column:gguf_gpu_layers"`
	ModelType     string         `yaml:"model_type" gorm:"column:model_type"`
	CreatedAt     time.Time      `yaml:"-"`
	UpdatedAt     time.Time      `yaml:"-"`
	DeletedAt     gorm.DeletedAt `gorm:"index" yaml:"-"`
}

// LoadConfig loads configuration from a YAML file.
func LoadConfig(fs afero.Fs, path string) (*AppConfig, error) {
	config := &AppConfig{}

	// Use Afero to read the file
	file, err := afero.ReadFile(fs, path)
	if err != nil {
		return nil, err
	}

	err = yaml.Unmarshal(file, config)
	if err != nil {
		return nil, err
	}

	return config, nil
}

func InitServer(configPath string) (string, error) {

	// WEB FILES
	webPath := filepath.Join(configPath, "web")
	err := os.MkdirAll(webPath, 0755)
	if err != nil {
		return "", fmt.Errorf("failed to create directory %s: %v", webPath, err)
	}
	err = CopyFiles(embedfs, "public", webPath)
	if err != nil {
		return "", fmt.Errorf("failed to copy files: %v", err)
	}

	// GGUF FILES
	ggufPath := filepath.Join(configPath, "gguf")
	err = os.MkdirAll(ggufPath, 0755)
	if err != nil {
		return "", fmt.Errorf("failed to create directory %s: %v", ggufPath, err)
	}
	err = CopyFiles(embedfs, "pkg/llm/local/bin", ggufPath)
	if err != nil {
		return "", fmt.Errorf("failed to copy files: %v", err)
	}

	files, err := os.ReadDir(ggufPath)
	if err != nil {
		return "", fmt.Errorf("failed to read directory %s: %v", ggufPath, err)
	}

	for _, file := range files {
		if !file.IsDir() {
			err = os.Chmod(filepath.Join(ggufPath, file.Name()), 0755)
			if err != nil {
				return "", fmt.Errorf("failed to set executable permission on file %s: %v", file.Name(), err)
			}
		}
	}

	// IMG GEN
	imgGenPath := filepath.Join(configPath, "sd")
	err = os.MkdirAll(imgGenPath, 0755)
	if err != nil {
		return "", fmt.Errorf("failed to create directory %s: %v", imgGenPath, err)
	}

	err = CopyFiles(embedfs, "pkg/sd/sdcpp/build/bin", imgGenPath)
	if err != nil {
		return "", fmt.Errorf("failed to copy files: %v", err)
	}

	files, err = os.ReadDir(imgGenPath)
	if err != nil {
		return "", fmt.Errorf("failed to read directory %s: %v", imgGenPath, err)
	}

	for _, file := range files {
		if !file.IsDir() {
			err = os.Chmod(filepath.Join(imgGenPath, file.Name()), 0755)
			if err != nil {
				return "", fmt.Errorf("failed to set executable permission on file %s: %v", file.Name(), err)
			}
		}
	}

	return configPath, nil
}

func EnsureDataPath(config *AppConfig) error {
	if _, err := os.Stat(config.DataPath); os.IsNotExist(err) {
		return LocalFs.MkdirAll(config.DataPath, os.ModePerm)
	}
	return nil
}

func CopyFiles(fsys embed.FS, srcDir, destDir string) error {
	fileEntries, err := fsys.ReadDir(srcDir)
	if err != nil {
		return fmt.Errorf("failed to read directory %s: %v", srcDir, err)
	}

	for _, entry := range fileEntries {
		srcPath := filepath.Join(srcDir, entry.Name())
		destPath := filepath.Join(destDir, entry.Name())

		if entry.IsDir() {
			// Create the directory and copy its contents
			if err := os.MkdirAll(destPath, 0755); err != nil {
				return fmt.Errorf("failed to create directory %s: %v", destPath, err)
			}
			if err := CopyFiles(fsys, srcPath, destPath); err != nil {
				return err
			}
		} else {
			// Copy the file
			fileData, err := fsys.ReadFile(srcPath)
			if err != nil {
				log.Errorf("failed to read file %s: %v", srcPath, err)
				continue // Skip to the next file
			}
			if err := os.WriteFile(destPath, fileData, 0755); err != nil {
				return fmt.Errorf("failed to write file %s: %v", destPath, err)
			}
		}
	}
	return nil
}

// Increments and returns a counter that gets appended to the id for frontend chat elements
func IncrementTurn() int64 {
	return atomic.AddInt64(&messageCounter, 1)
}

// findURLInText searches for a URL in a given text and returns it if found.
// It returns nil if no valid URL is found.
func URLParse(text string) *url.URL {
	// Define a regular expression for finding URLs
	// This is a simple regex for demonstration; it might not cover all URL cases
	re := regexp.MustCompile(`https?://[^\s]+`)

	// Find a URL using the regex
	found := re.FindString(text)
	if found == "" {
		// No URL found
		return nil
	}

	// Parse the URL to validate it and return *url.URL
	parsedURL, err := url.Parse(found)
	if err != nil {
		// The URL is not valid
		return nil
	}

	return parsedURL
}
--- END /Users/arturoaquino/Documents/eternal/config.go ---

